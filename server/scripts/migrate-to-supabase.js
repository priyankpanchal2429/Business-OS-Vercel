
const fs = require('fs');
const path = require('path');
const supabase = require('../config/supabase'); // Uses the config we created earlier
require('dotenv').config({ path: path.join(__dirname, '../.env.development') });

const DATA_FILE = path.join(__dirname, '../data/data.json'); // Main data file

async function migrate() {
    console.log('üöÄ Starting Migration to Supabase...');

    if (!fs.existsSync(DATA_FILE)) {
        console.error('‚ùå Data file not found:', DATA_FILE);
        process.exit(1);
    }

    const data = JSON.parse(fs.readFileSync(DATA_FILE, 'utf8'));
    console.log('üì¶ Data loaded from JSON. Mapping to SQL...');

    try {
        // 1. EMPLOYEES
        if (data.employees && data.employees.length > 0) {
            console.log(`‚û°Ô∏è  Migrating ${data.employees.length} Employees...`);
            const { error } = await supabase.from('employees').upsert(
                data.employees.map(e => ({
                    id: e.id,
                    name: e.name,
                    role: e.role,
                    image: e.image,
                    phone: e.phone,
                    address: e.address,
                    joiningDate: e.joiningDate,
                    salary: (e.salary === '' || e.salary === null) ? 0 : parseFloat(e.salary),
                    perShiftAmount: (e.perShiftAmount === '' || e.perShiftAmount === null) ? 0 : parseFloat(e.perShiftAmount),
                    shiftStart: e.shiftStart,
                    shiftEnd: e.shiftEnd,
                    status: e.status,
                    lastWorkingDay: e.lastWorkingDay,
                    bankDetails: e.bankDetails,
                    documents: e.documents
                }))
            );
            if (error) throw new Error(`Employees Migration Failed: ${error.message}`);
        }

        // 2. INVENTORY
        if (data.inventory && data.inventory.length > 0) {
            console.log(`‚û°Ô∏è  Migrating ${data.inventory.length} Inventory Items...`);
            const { error } = await supabase.from('inventory').upsert(
                data.inventory.map(i => ({
                    id: i.id,
                    name: i.name,
                    description: i.description,
                    category: i.category,
                    type: i.type,
                    quantity: i.quantity,
                    unit: i.unit,
                    price: i.price,
                    minStockLevel: i.minStockLevel,
                    location: i.location,
                    image: i.image,
                    vendor: i.vendor,
                    lastUpdated: i.lastUpdated ? new Date(i.lastUpdated) : new Date()
                }))
            );
            if (error) throw new Error(`Inventory Migration Failed: ${error.message}`);
        }

        // 3. VENDORS
        if (data.vendors && data.vendors.length > 0) {
            console.log(`‚û°Ô∏è  Migrating ${data.vendors.length} Vendors...`);
            const { error } = await supabase.from('vendors').upsert(
                data.vendors.map(v => ({
                    id: v.id,
                    name: v.name,
                    contactPerson: v.contactPerson,
                    phone: v.phone,
                    email: v.email,
                    gstin: v.gstin,
                    address: v.address,
                    category: v.category,
                    paymentTerms: v.paymentTerms
                }))
            );
            if (error) throw new Error(`Vendors Migration Failed: ${error.message}`);
        }

        // 4. TIMESHEET ENTRIES
        if (data.timesheet_entries && data.timesheet_entries.length > 0) {
            console.log(`‚û°Ô∏è  Migrating ${data.timesheet_entries.length} Timesheet Entries...`);
            // Batch insert to avoid payload limits
            const BATCH_SIZE = 500;
            for (let i = 0; i < data.timesheet_entries.length; i += BATCH_SIZE) {
                const batch = data.timesheet_entries.slice(i, i + BATCH_SIZE).map(e => ({
                    // unique_id will be auto-generated by DB if not provided, usually JSON won't have it unless new
                    employeeId: e.employeeId,
                    date: e.date,
                    clockIn: e.clockIn || e.shiftStart || null,
                    clockOut: e.clockOut || e.shiftEnd || null,
                    shiftStart: e.shiftStart,
                    shiftEnd: e.shiftEnd,
                    breakMinutes: e.breakMinutes,
                    dayType: e.dayType,
                    status: e.status
                }));
                const { error } = await supabase.from('timesheet_entries').upsert(batch, { onConflict: 'unique_id', ignoreDuplicates: false });
                // Note: without unique_id in source, upsert acts like insert unless we define conflict on other cols. 
                // Since this is one-time migration, insert should be fine, but upsert is safer if re-run.
                // However, without a unique constraint match, upsert inserts.
                // Assuming empty table for migration.
                if (error) throw new Error(`Timesheet Migration Failed (Batch ${i}): ${error.message}`);
            }
        }

        // 5. PAYROLL ENTRIES
        if (data.payroll_entries && data.payroll_entries.length > 0) {
            console.log(`‚û°Ô∏è  Migrating ${data.payroll_entries.length} Payroll Entries...`);
            const { error } = await supabase.from('payroll_entries').upsert(
                data.payroll_entries.map(p => ({
                    id: p.id,
                    employeeId: p.employeeId,
                    periodStart: p.periodStart,
                    periodEnd: p.periodEnd,
                    grossPay: p.grossPay,
                    deductions: p.deductions,
                    advanceDeductions: p.advanceDeductions,
                    loanDeductions: p.loanDeductions,
                    netPay: p.netPay,
                    status: p.status,
                    paidAt: p.paidAt,
                    paymentDetails: p.paymentDetails,
                    // Map frozen properties to frozenData JSONB
                    frozenData: p.isFrozen ? {
                        frozenEmployeeName: p.frozenEmployeeName,
                        frozenEmployeeRole: p.frozenEmployeeRole,
                        frozenEmployeeImage: p.frozenEmployeeImage,
                        frozenPerShiftAmount: p.frozenPerShiftAmount,
                        frozenHourlyRate: p.frozenHourlyRate,
                        frozenSalary: p.frozenSalary,
                        frozenTimesheet: p.frozenTimesheet,
                        frozenAdvances: p.frozenAdvances,
                        frozenLoans: p.frozenLoans,
                        frozenLoanSummary: p.frozenLoanSummary,
                        frozenBonus: p.frozenBonus
                    } : null,
                    perShiftAmount: p.perShiftAmount,
                    hourlyRate: p.hourlyRate,
                    totalOvertimeMinutes: p.totalOvertimeMinutes,
                    overtimePay: p.overtimePay
                }))
            );
            if (error) throw new Error(`Payroll Entries Migration Failed: ${error.message}`);
        }

        // 6. DEDUCTIONS
        if (data.deductions && data.deductions.length > 0) {
            console.log(`‚û°Ô∏è  Migrating ${data.deductions.length} Deductions...`);
            const { error } = await supabase.from('deductions').upsert(
                data.deductions.map(d => ({
                    id: d.id,
                    employeeId: d.employeeId,
                    periodStart: d.periodStart,
                    periodEnd: d.periodEnd,
                    type: d.type,
                    amount: d.amount,
                    description: d.description,
                    status: d.status,
                    linkedAdvanceId: d.linkedAdvanceId
                }))
            );
            if (error) throw new Error(`Deductions Migration Failed: ${error.message}`);
        }

        // 7. ADVANCE SALARIES
        if (data.advance_salaries && data.advance_salaries.length > 0) {
            console.log(`‚û°Ô∏è  Migrating ${data.advance_salaries.length} Advance Salaries...`);
            const { error } = await supabase.from('advance_salaries').upsert(
                data.advance_salaries.map(a => ({
                    id: a.id,
                    employeeId: a.employeeId,
                    amount: a.amount,
                    dateIssued: a.dateIssued,
                    reason: a.reason,
                    status: a.status
                }))
            );
            if (error) throw new Error(`Advance Salaries Migration Failed: ${error.message}`);
        }

        // 8. BONUS WITHDRAWALS
        if (data.bonus_withdrawals && data.bonus_withdrawals.length > 0) {
            console.log(`‚û°Ô∏è  Migrating ${data.bonus_withdrawals.length} Bonus Withdrawals...`);
            const { error } = await supabase.from('bonus_withdrawals').upsert(
                data.bonus_withdrawals.map(b => ({
                    id: b.id,
                    employeeId: b.employeeId,
                    amount: b.amount,
                    date: b.date,
                    notes: b.notes
                }))
            );
            if (error) throw new Error(`Bonus Withdrawals Migration Failed: ${error.message}`);
        }

        // 9. SETTINGS
        if (data.settings) {
            console.log(`‚û°Ô∏è  Migrating Settings...`);
            const settingsArray = Object.entries(data.settings).map(([key, value]) => ({
                key,
                value
            }));

            if (settingsArray.length > 0) {
                const { error } = await supabase.from('settings').upsert(settingsArray);
                if (error) throw new Error(`Settings Migration Failed: ${error.message}`);
            }
        }

        console.log('‚úÖ  Migration Complete! All data has been transferred to Supabase.');

    } catch (err) {
        console.error('‚ùå Migration Failed:', err.message);
        process.exit(1);
    }
}

migrate();
